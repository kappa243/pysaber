# Python implementation of SABER random number generator: https://github.com/KULeuven-COSIC/SABER/blob/master/Reference_Implementation_KEM/rng.c

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

# Constants
RNG_SUCCESS = 0
RNG_BAD_MAXLEN = -1
RNG_BAD_OUTBUF = -2
RNG_BAD_REQ_LEN = -3


# Class for storing the state of the AES-based XOF (eXtendable Output Function)
class AES_XOF_struct:
    def __init__(self):
        self.buffer = bytearray(16)       # Buffer to store intermediate output
        self.buffer_pos = 16              # Position in the buffer
        self.length_remaining = 0         # Remaining length of bytes to be generated
        self.key = bytearray(32)          # 256-bit AES key
        self.ctr = bytearray(16)          # 128-bit counter


# Class for storing the state of the AES-256 CTR DRBG (Deterministic Random Bit Generator)
class AES256_CTR_DRBG_struct:
    def __init__(self):
        self.Key = bytearray(32)          # 256-bit AES key
        self.V = bytearray(16)            # 128-bit counter (V value)
        self.reseed_counter = 0           # Reseed counter


DRBG_ctx = AES256_CTR_DRBG_struct()


def AES256_ECB(key, ctr, buffer):
    """
    Encrypts a 128-bit block using AES-256 in ECB mode.

    Args:
        key (bytes): 256-bit AES key.
        ctr (bytes): 128-bit input block to be encrypted.
        buffer (bytes): Output buffer to store the encrypted block.
    """
    backend = default_backend()
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
    encryptor = cipher.encryptor()
    encrypted = encryptor.update(ctr) + encryptor.finalize()
    buffer[: len(encrypted)] = encrypted


def seedexpander_init(ctx, seed, diversifier, maxlen):
    """
    Initializes the seed expander context with the provided seed, diversifier, and maximum length.

    Args:
        ctx (AES_XOF_struct): The context to initialize.
        seed (bytes): A 32-byte random seed.
        diversifier (bytes): An 8-byte diversifier.
        maxlen (int): Maximum number of bytes to generate.

    Returns:
        int: RNG_SUCCESS if successful, otherwise an error code.
    """
    if maxlen >= 0x100000000:
        return RNG_BAD_MAXLEN

    ctx.length_remaining = maxlen
    ctx.key[:] = seed

    ctx.ctr[:8] = diversifier
    ctx.ctr[8:12] = [(maxlen >> (8 * i)) & 0xFF for i in range(4)][::-1]
    ctx.ctr[12:] = b"\x00\x00\x00\x00"

    ctx.buffer_pos = 16
    ctx.buffer[:] = b"\x00" * 16

    return RNG_SUCCESS


def seedexpander(ctx, x, xlen):
    """
    Generates random bytes using the seed expander context.

    Args:
        ctx (AES_XOF_struct): The seed expander context.
        x (bytes): Output buffer to store the generated bytes.
        xlen (int): Number of bytes to generate.

    Returns:
        int: RNG_SUCCESS if successful, otherwise an error code.
    """
    if x is None:
        return RNG_BAD_OUTBUF
    if xlen >= ctx.length_remaining:
        return RNG_BAD_REQ_LEN

    ctx.length_remaining -= xlen
    offset = 0

    while xlen > 0:
        if xlen <= (16 - ctx.buffer_pos):
            x[offset : offset + xlen] = ctx.buffer[ctx.buffer_pos : ctx.buffer_pos + xlen]
            ctx.buffer_pos += xlen
            return RNG_SUCCESS

        x[offset : offset + (16 - ctx.buffer_pos)] = ctx.buffer[ctx.buffer_pos : 16]
        xlen -= 16 - ctx.buffer_pos
        offset += 16 - ctx.buffer_pos

        AES256_ECB(ctx.key, ctx.ctr, ctx.buffer)
        ctx.buffer_pos = 0

        for i in range(15, 11, -1):
            if ctx.ctr[i] == 0xFF:
                ctx.ctr[i] = 0x00
            else:
                ctx.ctr[i] += 1
                break

    return RNG_SUCCESS


def randombytes_init(entropy_input, personalization_string=None, security_strength=256):
    """
    Initializes the random number generator with the given entropy input and optional personalization string.

    Args:
        entropy_input (bytes): Initial entropy input.
        personalization_string (bytes, optional): Optional personalization string. Defaults to None.
        security_strength (int, optional): Security strength of the DRBG. Defaults to 256.
    """
    seed_material = bytearray(entropy_input[:48])
    if personalization_string:
        seed_material = bytearray([seed_material[i] ^ personalization_string[i] for i in range(48)])

    DRBG_ctx.Key[:] = b"\x00" * 32
    DRBG_ctx.V[:] = b"\x00" * 16
    AES256_CTR_DRBG_Update(seed_material, DRBG_ctx.Key, DRBG_ctx.V)
    DRBG_ctx.reseed_counter = 1


def randombytes(x, xlen):
    """
    Generates a specified number of random bytes.

    Args:
        x (bytes): Output buffer to store the generated random bytes.
        xlen (int): Number of random bytes to generate.

    Returns:
        int: RNG_SUCCESS if successful.
    """
    block = bytearray(16)
    i = 0

    while xlen > 0:
        for j in range(15, -1, -1):
            if DRBG_ctx.V[j] == 0xFF:
                DRBG_ctx.V[j] = 0x00
            else:
                DRBG_ctx.V[j] += 1
                break

        AES256_ECB(DRBG_ctx.Key, DRBG_ctx.V, block)

        if xlen > 15:
            x[i : i + 16] = block
            i += 16
            xlen -= 16
        else:
            x[i : i + xlen] = block[:xlen]
            xlen = 0

    AES256_CTR_DRBG_Update(None, DRBG_ctx.Key, DRBG_ctx.V)
    DRBG_ctx.reseed_counter += 1

    return RNG_SUCCESS


def AES256_CTR_DRBG_Update(provided_data, Key, V):
    """
    Updates the internal state of the AES-256 CTR DRBG.

    Args:
        provided_data (bytes, optional): Optional additional data to update the state.
        Key (bytes): The 256-bit AES key to be updated.
        V (bytes): The 128-bit counter to be updated.
    """
    temp = bytearray(48)

    for i in range(3):
        for j in range(15, -1, -1):
            if V[j] == 0xFF:
                V[j] = 0x00
            else:
                V[j] += 1
                break

        temp_view = memoryview(temp)[16 * i : 16 * (i + 1)]
        AES256_ECB(Key, V, temp_view)

    if provided_data:
        temp = bytearray([temp[i] ^ provided_data[i] for i in range(48)])

    Key[:] = temp[:32]
    V[:] = temp[32:48]
